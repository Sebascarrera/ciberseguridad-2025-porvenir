import { useEffect, useRef, useState, useImperativeHandle, forwardRef } from "react";
import { useNavigate } from "react-router-dom";
import "../styles/escapa-malware-play.css";

/**
 * Escapa del Malware ‚Äì Play
 * - Parallax continuo capa 1‚Äì3 (siempre) + capa 4 solo en tramo
 * - Speedlines en canvas + efectos ne√≥n
 * - Malware con animaci√≥n ‚Äúrun/bob‚Äù siempre; cruce al acertar
 * - 9 preguntas m√∫ltiple respuesta
 * - Acierto: avatar salta + avanza; malware sale a la izquierda + confeti
 * - Error: avatar ‚Äúcrash‚Äù + avance corto; malware se acerca simulando golpe
 * - Stage arriba, preguntas abajo
 */

// üñºÔ∏è Cambia estos imports por tus assets reales
import bg1 from "../../../assets/img/em-bg-1.png";
import bg2 from "../../../assets/img/em-bg-2.png";
import bg3 from "../../../assets/img/em-bg-3.png";
import bg4 from "../../../assets/img/em-bg-4.png";
import avatarRun from "../../../assets/img/em-avatar-run.png";
import avatarJump from "../../../assets/img/em-avatar-jump.png";
import avatarCrash from "../../../assets/img/em-avatar-crash.png";
import obstacleImg from "../../../assets/img/em-malware.png";

// Obst√°culos espec√≠ficos por pregunta (usa tus assets reales)
import obsVirus     from "../../../assets/img/obs-virus.png";
import obsTroyano   from "../../../assets/img/obs-troyano.png";
import obsRansom    from "../../../assets/img/obs-ransomware.png";
import obsSpyware   from "../../../assets/img/obs-spyware.png";
import obsAdware    from "../../../assets/img/obs-adware.png";
import obsKeylogger from "../../../assets/img/obs-keylogger.png";
import obsWorm      from "../../../assets/img/obs-worm.png";
import obsBotnet    from "../../../assets/img/obs-botnet.png";
import obsRootkit   from "../../../assets/img/obs-rootkit.png";


/* =========================== Preguntas =========================== */
const QUESTIONS = [
  // Virus
  {
    q: "Un virus necesita que el usuario ejecute un archivo infectado para propagarse.",
    opts: ["Verdadero", "Falso"],
    ok: 0,
    obstacle: obsVirus
  },
  // Troyano
  {
    q: "¬øC√≥mo entra un troyano a un equipo?",
    opts: [
      "Dej√°ndolo prendido toda la noche",
      "V√≠a cable de red sin aviso",
      "Con el consentimiento del usuario disfrazado de programa leg√≠timo",
      "Solo por USB"
    ],
    ok: 2,
    obstacle: obsTroyano
  },
  // Ransomware
  {
    q: "¬øQu√© hace el ransomware?",
    opts: [
      "Borrar archivos de inmediato",
      "Cifrar/bloquear archivos y pedir rescate",
      "Mostrar anuncios molestos",
      "Instalar Firewall"
    ],
    ok: 1,
    obstacle: obsRansom
  },
  // Spyware
  {
    q: "El Spyware se instala sin el consentimiento del usuario para espiar su actividad, monitorear el uso de internet y robar datos confidenciales.",
    opts: ["Verdadero", "Falso"],
    ok: 0,
    obstacle: obsSpyware
  },
  // Adware malicioso
  {
    q: "El adware malicioso se caracteriza por:",
    opts: [
      "Mostrar publicidad no deseada",
      "Crear copias de seguridad",
      "Optimizar el sistema",
      "Pedir dinero a cambio de liberar archivos"
    ],
    ok: 0,
    obstacle: obsAdware
  },
  // Keylogger
  {
    q: "¬øQu√© informaci√≥n roba un keylogger?",
    opts: [
      "Fotos de la galer√≠a",
      "Todo lo que se escribe en el teclado",
      "Se√±al WiFi",
      "Videos de Instagram"
    ],
    ok: 1,
    obstacle: obsKeylogger
  },
  // Worm (gusano)
  {
    q: "A diferencia de los virus, un gusano se propaga autom√°ticamente sin necesidad de la acci√≥n del usuario.",
    opts: ["Verdadero", "Falso"],
    ok: 0,
    obstacle: obsWorm
  },
  // Botnet
  {
    q: "¬øPara qu√© usan los ciberdelincuentes una botnet?",
    opts: [
      "Para compartir pel√≠culas",
      "Para no pagar internet",
      "Para reparar equipos",
      "Para lanzar ataques masivos como DDoS"
    ],
    ok: 3,
    obstacle: obsBotnet
  },
  // Rootkit
  {
    q: "Un rootkit se usa principalmente para:",
    opts: [
      "Dar privilegios ocultos (de administrador) al atacante",
      "Bloquear anuncios",
      "Limpiar archivos temporales",
      "Imitar una voz con IA"
    ],
    ok: 0,
    obstacle: obsRootkit
  }
];
const TOTAL_QUESTIONS = QUESTIONS.length;
const MAX_LIVES = 3;


/* =========================== CONFETI (canvas) =========================== */
const ConfettiCanvas = forwardRef(function ConfettiCanvas(_, ref) {
  const canvasRef = useRef(null);
  const rafRef = useRef(0);
  const partsRef = useRef([]);
  const ctxRef = useRef(null);
  const DPR = useRef(Math.max(1, window.devicePixelRatio || 1));
  const colors = ["#06d6a0","#3a86ff","#ffbe0b","#ef476f","#7cc9ff","#8affd3"];

  useEffect(() => {
    function resize() {
      const c = canvasRef.current; if (!c) return;
      const dpr = DPR.current;
      c.width = Math.floor(window.innerWidth * dpr);
      c.height = Math.floor(window.innerHeight * dpr);
      c.style.width = window.innerWidth + "px";
      c.style.height = window.innerHeight + "px";
      const ctx = c.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctxRef.current = ctx;
    }
    resize();
    window.addEventListener("resize", resize);
    return () => window.removeEventListener("resize", resize);
  }, []);

  useEffect(() => {
    let last = 0;
    function tick(ts) {
      const ctx = ctxRef.current;
      if (!ctx) { rafRef.current = requestAnimationFrame(tick); return; }
      const dt = Math.min(32, ts - last || 16);
      last = ts;
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      partsRef.current = partsRef.current.filter(p => p.life > 0);
      for (const p of partsRef.current) {
        p.vx *= 0.995; p.vy = p.vy * 0.995 + 0.18;
        p.x += p.vx; p.y += p.vy;
        p.r += p.spin;
        p.life -= dt * 0.07;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.r);
        ctx.globalAlpha = Math.max(0, Math.min(1, p.life / 100));
        ctx.fillStyle = p.color;
        if (p.shape === "rect") ctx.fillRect(-p.size*.6, -p.size*.35, p.size*1.2, p.size*.7);
        else { ctx.beginPath(); ctx.arc(0,0,p.size*.5,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
      }
      rafRef.current = requestAnimationFrame(tick);
    }
    rafRef.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(rafRef.current);
  }, []);

  useImperativeHandle(ref, () => ({
    burst({ x, y, count = 120, power = 7 }) {
      if (partsRef.current.length > 600) partsRef.current.splice(0, 200);
      for (let i = 0; i < count; i++) {
        const a = (-90 + (Math.random()*60 - 30)) * (Math.PI/180);
        const s = (Math.random() * 0.6 + 0.7) * power;
        partsRef.current.push({
          x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
          r: Math.random()*Math.PI, spin: (Math.random()*0.2 - 0.1),
          life: 100 + Math.random()*40, size: 6 + Math.random()*8,
          color: colors[Math.floor(Math.random()*colors.length)],
          shape: Math.random() < 0.65 ? "rect" : "dot",
        });
      }
    }
  }));

  return <canvas className="em-confetti" ref={canvasRef} />;
});

/* ==================== SPEEDLINES (canvas sin bandas) ==================== */
function SpeedlinesCanvas({ running, intensity = 0.8 }) {
  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const DPR = useRef(Math.max(1, window.devicePixelRatio || 1));
  const rafRef = useRef(0);
  const streaksRef = useRef([]);
  const runningRef = useRef(running);
  const intensityRef = useRef(intensity);

  useEffect(() => { runningRef.current = running; }, [running]);
  useEffect(() => { intensityRef.current = intensity; }, [intensity]);

  useEffect(() => {
    function resize() {
      const c = canvasRef.current; if (!c) return;
      const dpr = DPR.current;
      const rect = c.parentElement?.getBoundingClientRect();
      const w = rect ? rect.width : window.innerWidth;
      const h = rect ? rect.height : window.innerHeight;
      c.width = Math.floor(w * dpr);
      c.height = Math.floor(h * dpr);
      c.style.width = w + "px";
      c.style.height = h + "px";
      const ctx = c.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctxRef.current = ctx;
    }
    resize();
    window.addEventListener("resize", resize);
    return () => window.removeEventListener("resize", resize);
  }, []);

  function spawn(w, h, mult = 1) {
    const count = Math.floor((6 + Math.random() * 5) * mult); // 6‚Äì11 por burst
    for (let i = 0; i < count; i++) {
      const y = Math.random() * (h - 90) + 10; // evita el suelo
      const len = 40 + Math.random() * 180;
      const speed = 900 + Math.random() * 900; // px/s
      const alpha = 0.12 + Math.random() * 0.23;
      const width = 1 + Math.random() * 2.4;
      const tilt = -0.18 + Math.random() * 0.08; // ~ -10¬∞ a -3¬∞
      streaksRef.current.push({
        x: w + Math.random() * (w * 0.4),
        y,
        vx: -speed,
        vy: 0,
        len,
        width,
        alpha,
        tilt,
        life: 320 + Math.random() * 200 // ms
      });
    }
  }

  useEffect(() => {
    let lastTs = 0;
    function tick(ts) {
      const ctx = ctxRef.current, c = canvasRef.current;
      if (!ctx || !c) { rafRef.current = requestAnimationFrame(tick); return; }
      const dt = Math.min(32, ts - lastTs || 16) / 1000;
      lastTs = ts;
      const w = c.width / DPR.current, h = c.height / DPR.current;

      ctx.clearRect(0, 0, w, h);

      if (runningRef.current) {
        const mult = intensityRef.current; // 0.6 fallo, 1.0 acierto
        spawn(w, h, mult * dt * 60 / 16); // normaliza vs. framerate
      }

      streaksRef.current = streaksRef.current.filter(s => s.life > 0 && s.x + s.len > -60);
      for (const s of streaksRef.current) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.life -= dt * 1000;

        ctx.save();
        ctx.globalCompositeOperation = "screen";
        ctx.globalAlpha = Math.max(0, Math.min(1, s.alpha * (s.life / 320)));
        ctx.translate(s.x, s.y);
        ctx.rotate(s.tilt);
        const grad = ctx.createLinearGradient(0, 0, -s.len, 0);
        grad.addColorStop(0, "rgba(255,255,255,0)");
        grad.addColorStop(0.25, "rgba(200,220,255,0.45)");
        grad.addColorStop(0.6, "rgba(140,200,255,0.25)");
        grad.addColorStop(1, "rgba(100,180,255,0.0)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = s.width;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-s.len, 0);
        ctx.stroke();
        ctx.restore();
      }

      rafRef.current = requestAnimationFrame(tick);
    }
    rafRef.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(rafRef.current);
  }, []);

  return <canvas className="em-speedlines-canvas" aria-hidden="true" ref={canvasRef} />;
}

// Suma puntos al marcador global (localStorage + evento opcional)
function awardPoints(points) {
  try {
    const KEY = "gameHub:score";
    const current = parseInt(localStorage.getItem(KEY) || "0", 10) || 0;
    const updated = current + (Number.isFinite(points) ? points : 0);
    localStorage.setItem(KEY, String(updated));
    // Notifica a quien escuche (opcional)
    window.dispatchEvent(new CustomEvent("globalScore:add", {
      detail: { delta: points, total: updated }
    }));
    if (typeof window.__dispatchScore === "function") {
      window.__dispatchScore(points);
    }
  } catch {
    // no-op
  }
}

/* =========================== Utilidades =========================== */
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

/* =========================== Play =========================== */
export default function MalwarePlay() {
  const navigate = useNavigate();

  // Parallax offsets
  const [bg, setBg] = useState({ l1: 0, l2: 0, l3: 0, l4: 0 });
  const movingRef = useRef(false);
  const rafRef = useRef(0);
  const runUntilRef = useRef(0);

  // Velocidades:
  //  - base (siempre) para capas 1‚Äì3
  //  - boost (tramo) para capas 1‚Äì3 (sutil) y 4 (principal)
  const baseSpeedsRef = useRef({ l1: 40, l2: 90, l3: 160 });  // px/s continuo
  const boostSpeedsRef = useRef({ l1: 80, l2: 150, l3: 240, l4: 520 }); // px/s en tramo
  const runBoostRef = useRef(1); // multiplicador por acierto/fallo

  // HUD / Juego
  const [idx, setIdx] = useState(0);
  const [lives, setLives] = useState(MAX_LIVES);
  const [score, setScore] = useState(0);
  const [ended, setEnded] = useState(false);
  const [lock, setLock] = useState(false);

  // Sprites y desplazamientos laterales
  const [avatarState, setAvatarState] = useState("run"); // 'run' | 'jump' | 'crash'
  const [advance, setAdvance] = useState(null);          // null | 'good' | 'bad'
  const [isRunning, setIsRunning] = useState(false);     // activa speedlines
  const [lineIntensity, setLineIntensity] = useState(0.8);

  const confettiRef = useRef(null);
  const stageRef = useRef(null);

  // Loop parallax (capas 1‚Äì3 siempre; capa 4 solo en tramo)
  useEffect(() => {
    let last = 0;
    function tick(ts) {
      const dt = Math.min(32, ts - last || 16) / 1000; // s
      last = ts;

      const base = baseSpeedsRef.current;
      const boost = boostSpeedsRef.current;

      // easing del tramo (si est√° corriendo)
      let e = 0;
      if (movingRef.current) {
        const now = performance.now();
        const t = Math.min(1, Math.max(0, 1 - (runUntilRef.current - now) / RUN_DURATION));
        e = easeOutCubic(1 - t); // r√°pido al inicio, frena al final
        if (now >= runUntilRef.current) {
          movingRef.current = false;
          runBoostRef.current = 1;
          setIsRunning(false);
        }
      }

      // deltas
      const d1 = base.l1 * dt + (movingRef.current ? boost.l1 * runBoostRef.current * dt * (0.5 * e) : 0);
      const d2 = base.l2 * dt + (movingRef.current ? boost.l2 * runBoostRef.current * dt * (0.7 * e) : 0);
      const d3 = base.l3 * dt + (movingRef.current ? boost.l3 * runBoostRef.current * dt * (0.9 * e) : 0);
      const d4 = (movingRef.current ? boost.l4 * runBoostRef.current * dt * e : 0);

      setBg(prev => ({
        l1: (prev.l1 + d1) % 20000,
        l2: (prev.l2 + d2) % 20000,
        l3: (prev.l3 + d3) % 20000,
        l4: (prev.l4 + d4) % 20000,
      }));

      rafRef.current = requestAnimationFrame(tick);
    }
    rafRef.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(rafRef.current);
  }, []);

  const RUN_DURATION = 1100; // ms por tramo

  function startRun() {
    movingRef.current = true;
    runUntilRef.current = performance.now() + RUN_DURATION;
    setIsRunning(true);
  }

  function burstConfetti() {
    const rect = stageRef.current?.getBoundingClientRect();
    const x = rect ? rect.left + rect.width * 0.6 : window.innerWidth * 0.6;
    const y = rect ? rect.top + rect.height * 0.5 + window.scrollY : window.innerHeight * 0.5;
    confettiRef.current?.burst({ x, y, count: 120, power: 8 });
  }

  function handleAnswer(choiceIdx) {
    if (lock || ended) return;
    setLock(true);

    const current = QUESTIONS[idx];
    const correct = choiceIdx === current.ok;

    // Boost + parallax + desplazamientos laterales + speedlines
    runBoostRef.current = correct ? 1.8 : 1.15;
    setLineIntensity(correct ? 1.0 : 0.6);
    startRun();
    setAdvance(correct ? "good" : "bad");

    // Sprites + score/vidas
    if (correct) {
      setAvatarState("jump");
      setScore((s) => s + 100);
      burstConfetti();
    } else {
      setAvatarState("crash");
    }
    const postLives = correct ? lives : Math.max(0, lives - 1);
    if (!correct) setLives(postLives);

    // Siguiente fase
    setTimeout(() => {
      if (!correct && postLives <= 0) {
        setEnded(true);
        awardPoints(score);
        return;
      }
      const next = idx + 1;
      if (next >= TOTAL_QUESTIONS) {
        setEnded(true);
        awardPoints(score);
        return;
      }
      // Reset para la siguiente pregunta
      setIdx(next);
      setAvatarState("run");
      setAdvance(null);
      setLock(false);
    }, RUN_DURATION);
  }

  function resetGame() {
    setIdx(0); setLives(MAX_LIVES); setScore(0); setEnded(false);
    setAvatarState("run"); setAdvance(null); setLock(false);
    setBg({ l1:0, l2:0, l3:0, l4:0 });
    setIsRunning(false);
    setLineIntensity(0.8);
    runBoostRef.current = 1;
  }

  const q = QUESTIONS[idx];

  return (
    <div
      className="em-play-wrap"
      style={{
        "--em-bg1": `url(${bg1})`,
        "--em-bg2": `url(${bg2})`,
        "--em-bg3": `url(${bg3})`,
        "--em-bg4": `url(${bg4})`,
        "--em-bg1-x": `-${bg.l1}px`,
        "--em-bg2-x": `-${bg.l2}px`,
        "--em-bg3-x": `-${bg.l3}px`,
        "--em-bg4-x": `-${bg.l4}px`,
      }}
    >
      <ConfettiCanvas ref={confettiRef} />

      {/* Overlays de ne√≥n */}
      <div className="em-neon-glow" aria-hidden="true" />
      <div className="em-neon-scan" aria-hidden="true" />
      <div className="em-neon-sparkles" aria-hidden="true" />

      {/* HUD */}
      <header className="em-hud">
        <button className="em-ghost-btn" onClick={() => navigate("/selector")} type="button">‚¨Ö Volver</button>
        <div className="em-progress">
          <span>Pregunta {idx + 1} / {TOTAL_QUESTIONS}</span>
          <div className="em-progress-track"><div className="em-progress-fill" style={{ width: `${((idx) / TOTAL_QUESTIONS) * 100}%` }} /></div>
        </div>
        <div className="em-hud-right">
          <div className="em-score"><span className="lbl">Puntos</span><span className="val">{score}</span></div>
          <Lives lives={lives} />
        </div>
      </header>

      {/* Stage */}
      <main className={`em-stage ${isRunning ? "running" : ""}`} ref={stageRef}>
        {/* ‚¨áÔ∏è Muevo los fondos AQU√ç para que se ajusten al alto del stage */}
        <div className="em-bg l1" />
        <div className="em-bg l2" />
        <div className="em-bg l3" />
        <div className="em-bg l4" />

        {/* Speedlines en Canvas */}
        <SpeedlinesCanvas running={isRunning} intensity={lineIntensity} />

        {/* Suelo */}
        <div className="em-ground" />

        {/* Avatar */}
        <div className={`em-avatar ${advance ? `advance ${advance}` : ""}`}>
          <div className={`em-avatar-sprite ${avatarState}`}>
            <img
              src={avatarState === "jump" ? avatarJump : (avatarState === "crash" ? avatarCrash : avatarRun)}
              alt="Avatar"
              draggable="false"
            />
          </div>
        </div>

        {/* Obst√°culo (malware) */}
        <div className={`em-obstacle ${advance ? `approach ${advance}` : ""}`}>
          <div className={`em-obstacle-sprite ${advance === "bad" ? "hit" : "run"}`}>
            <img src={q?.obstacle || obstacleImg} alt="Malware" draggable="false" />
          </div>
        </div>
      </main>


      {/* Panel de preguntas */}
      {!ended && (
        <section className="em-quiz">
          <div className="em-card">
            <h3 className="em-q">{q.q}</h3>
            <div className="em-opts">
              {q.opts.map((opt, i) => (
                <button
                  key={i}
                  className="em-opt"
                  disabled={lock}
                  onClick={() => handleAnswer(i)}
                >
                  {opt}
                </button>
              ))}
            </div>
            <p className="em-tip">Elige la respuesta. Acierta para saltar el obst√°culo ü¶ò</p>
          </div>
        </section>
      )}

      {/* Modal fin */}
      {ended && (
        <div className="em-modal-wrap">
          <div className="em-modal">
            <h3>¬°Fin del juego!</h3>
            <div className="em-results">
              <div><strong>Puntaje:</strong> {score}</div>
              <div><strong>Preguntas:</strong> {idx >= TOTAL_QUESTIONS ? TOTAL_QUESTIONS : idx}</div>
              <div><strong>Vidas restantes:</strong> {lives}</div>
            </div>
            <div className="em-modal-actions">
              <button className="em-btn ok" onClick={resetGame}>Reintentar</button>
              <button className="em-btn sec" onClick={() => navigate("/selector")}>Salir</button>
            </div>
            <p className="em-save-hint">Tu puntaje se sum√≥ al total global.</p>
          </div>
        </div>
      )}
    </div>
  );
}

function Lives({ lives }) {
  return (
    <div className="em-lives">
      {new Array(MAX_LIVES).fill(0).map((_, i) => (
        <span key={i} className={`em-heart ${i < lives ? "on" : ""}`}>‚ù§</span>
      ))}
    </div>
  );
}
